<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        #world { 
            width: 100vw; 
            height: 100vh; 
        }
        .instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        #loading-bar {
            width: 200px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin: 20px 0;
            overflow: hidden;
        }
        #loading-progress {
            width: 0%;
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s ease;
        }
        #game-ui {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 20px;
            line-height: 20px;
            text-align: center;
        }
        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            overflow: hidden;
        }
        #minimap-content {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .minimap-player {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #3498db;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .minimap-enemy {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #ff9900;
        }
        .minimap-direction {
            position: absolute;
            width: 0;
            height: 0;
            top: 50%;
            left: 50%;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 8px solid #3498db;
            transform: translate(-50%, -50%);
        }
        #health-bar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            overflow: hidden;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background: #e74c3c;
            transition: width 0.3s ease;
        }
        #ammo-counter {
            position: fixed;
            bottom: 50px;
            left: 20px;
            color: white;
            font-size: 20px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #kill-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 20px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #fps-counter {
            position: fixed;
            top: 50px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
        }
        #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1100;
            color: white;
            pointer-events: all;
        }
        #game-over h1 {
            font-size: 48px;
            margin-bottom: 10px;
        }
        #game-over h2 {
            font-size: 24px;
            margin-bottom: 20px;
            font-weight: normal;
        }
        #restart-button {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.3s ease;
            pointer-events: all;
        }
        #restart-button:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <div class="instructions">
        WASD to move | Mouse to aim | Left Click to shoot | R to reload | Space to jump | Shift to sprint | Survive the air assault!
    </div>
    <div id="preloader">
        <h2>Loading Game...</h2>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
        <p>Please wait while assets are loading...</p>
    </div>
    
    <div id="world"></div>
    
    <div id="game-ui">
        <div id="crosshair">+</div>
        <div id="minimap">
            <div id="minimap-content">
                <div class="minimap-player"></div>
                <div class="minimap-direction"></div>
            </div>
        </div>
        <div id="health-bar">
            <div id="health-fill"></div>
        </div>
        <div id="ammo-counter">30 / 300</div>
        <div id="kill-counter">Kills: 0</div>
    </div>
    
    <div id="fps-counter">FPS: --</div>
    
    <div id="game-over">
        <h1 id="game-over-title">Mission Failed</h1>
        <h2 id="game-over-subtitle"></h2>
        <button id="restart-button">Try Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script>
        // Game variables
        let assetsLoaded = 0;
        const totalAssets = 4; // HDR, terrain texture, terrain, heli.png
        let kills = 0;
        let health = 100;
        let currentAmmo = 30;
        let totalAmmo = 300;
        let reloading = false;
        let gameActive = true;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        const maxEnemies = 10;
        let backgroundMusic;

        function updateLoadingProgress() {
            assetsLoaded++;
            const progress = assetsLoaded / totalAssets * 100;
            document.querySelector('#loading-progress').style.width = progress + '%';
            if (assetsLoaded >= totalAssets) {
                setTimeout(() => {
                    document.querySelector('#preloader').style.display = 'none';
                    spawnEnemies();
                    startBackgroundMusic();
                    animate();
                }, 500);
            }
        }

        // Music functions
        function startBackgroundMusic() {
            if (!backgroundMusic) {
                backgroundMusic = new Audio('./energetic.mp3'); // Replace with your music file
                backgroundMusic.loop = true;
                backgroundMusic.volume = 0.5;
            }
            backgroundMusic.play().catch(error => console.error('Music play error:', error));
        }

        function stopBackgroundMusic() {
            if (backgroundMusic) backgroundMusic.pause();
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('world').appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        
        new THREE.RGBELoader()
            .setDataType(THREE.UnsignedByteType)
            .load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/sunset_in_the_chalk_quarry_1k.hdr', function(texture) {
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                scene.background = envMap;
                texture.dispose();
                pmremGenerator.dispose();
                updateLoadingProgress();
            });

        const terrainGeometry = new THREE.PlaneBufferGeometry(200, 200, 32, 32); // Further reduced resolution
        const positions = terrainGeometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const y = positions[i + 1];
            positions[i + 2] = (Math.sin(x * 0.03) * Math.cos(y * 0.03) * 2);
        }
        terrainGeometry.computeVertexNormals();

        const textureLoader = new THREE.TextureLoader();
        const terrainMaterial = new THREE.MeshBasicMaterial({
            map: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/terrain/grasslight-big.jpg', updateLoadingProgress),
            color: 0x777777
        });

        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        scene.add(terrain);
        updateLoadingProgress();

        let heliTexture;
        textureLoader.load('./heli.png', function(texture) {
            heliTexture = texture;
            updateLoadingProgress();
        });

        const player = {
            height: 2,
            radius: 0.5,
            speed: 0.2,
            sprintMultiplier: 2,
            turnSpeed: 0.003,
            jumpForce: 0.3,
            gravity: 0.015,
            velocity: new THREE.Vector3(),
            canJump: false
        };

        function getHeightAtPosition(x, z) {
            const localX = x + 100;
            const localZ = z + 100;
            const u = localX / 200;
            const v = localZ / 200;
            const cellsPerSide = 32;
            const gridX = Math.floor(u * cellsPerSide);
            const gridZ = Math.floor(v * cellsPerSide);
            if (gridX < 0 || gridX >= cellsPerSide || gridZ < 0 || gridZ >= cellsPerSide) return 0;
            const index = (gridZ * (cellsPerSide + 1) + gridX) * 3 + 2;
            return positions[index] || 0;
        }

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        class Bullet {
            constructor(position, direction, isEnemy = false) {
                this.position = position.clone();
                this.direction = direction.clone().normalize();
                this.speed = isEnemy ? 1.5 : 2;
                this.damage = isEnemy ? 15 : 20;
                this.active = true;
                this.distanceTraveled = 0;
                this.maxDistance = 50;
                this.isEnemy = isEnemy;

                this.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({ color: isEnemy ? 0xff00ff : 0xff0000 })
                );
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            update(delta) {
                if (!this.active) return;

                this.position.add(this.direction.clone().multiplyScalar(this.speed * delta));
                this.mesh.position.copy(this.position);
                this.distanceTraveled += this.speed * delta;

                if (this.distanceTraveled > this.maxDistance) {
                    this.remove();
                    return;
                }

                if (this.isEnemy) {
                    const distance = this.position.distanceTo(camera.position);
                    if (distance < player.radius) {
                        takeDamage(this.damage);
                        this.remove();
                    }
                } else {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const distance = this.position.distanceTo(enemy.position);
                        if (distance < 2) {
                            enemy.takeDamage(this.damage);
                            this.remove();
                            break;
                        }
                    }
                }
            }

            remove() {
                this.active = false;
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                const array = this.isEnemy ? enemyBullets : bullets;
                const index = array.indexOf(this);
                if (index !== -1) array.splice(index, 1);
            }
        }

        class AirborneEnemy {
            constructor() {
                this.position = new THREE.Vector3();
                this.health = 100;
                this.active = true;
                this.speed = 0.2; // Increased for visible movement
                this.attackRange = 25;
                this.lastShot = 0;
                this.shootCooldown = 500;
                this.flightHeight = 10;
                this.setupSprite();
                this.setupMinimap();
                this.spawn();
            }

            setupSprite() {
                if (!heliTexture) return;
                const material = new THREE.SpriteMaterial({ map: heliTexture, transparent: true });
                this.sprite = new THREE.Sprite(material);
                this.sprite.scale.set(4, 4, 1);
                this.sprite.position.copy(this.position);
                scene.add(this.sprite);
            }

            setupMinimap() {
                this.minimapElement = document.createElement('div');
                this.minimapElement.className = 'minimap-enemy';
                document.getElementById('minimap-content').appendChild(this.minimapElement);
            }

            spawn() {
                let distance;
                do {
                    this.position.x = (Math.random() - 0.5) * 100;
                    this.position.z = (Math.random() - 0.5) * 100;
                    distance = this.position.distanceTo(new THREE.Vector3(0, 0, 0));
                } while (distance < 20 || distance > 80);
                this.position.y = getHeightAtPosition(this.position.x, this.position.z) + this.flightHeight;
                if (this.sprite) this.sprite.position.copy(this.position);
            }

            update(delta) {
                if (!this.active || !this.sprite) return;

                const target = camera.position.clone();
                const direction = target.sub(this.position).normalize();
                
                this.position.add(direction.multiplyScalar(this.speed * delta));
                this.position.y = getHeightAtPosition(this.position.x, this.position.z) + this.flightHeight;

                this.sprite.position.copy(this.position);
                this.sprite.lookAt(camera.position);

                const distance = this.position.distanceTo(camera.position);
                if (distance < this.attackRange && gameActive) {
                    this.shoot(direction);
                }
                
                this.updateMinimap();
            }

            shoot(direction) {
                const now = performance.now();
                if (now - this.lastShot < this.shootCooldown) return;
                this.lastShot = now;
                const bullet = new Bullet(this.position.clone(), direction, true);
                enemyBullets.push(bullet);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.remove();
                    kills++;
                    document.getElementById('kill-counter').textContent = `Kills: ${kills}`;
                    checkWinCondition();
                }
            }

            updateMinimap() {
                const minimapSize = 150;
                const worldSize = 200;
                const relX = (this.position.x - camera.position.x) / worldSize * minimapSize;
                const relZ = (this.position.z - camera.position.z) / worldSize * minimapSize;
                this.minimapElement.style.left = (75 + relX) + 'px';
                this.minimapElement.style.top = (75 + relZ) + 'px';
            }

            remove() {
                this.active = false;
                if (this.sprite) scene.remove(this.sprite);
                this.minimapElement.remove();
                const index = enemies.indexOf(this);
                if (index !== -1) enemies.splice(index, 1);
            }
        }

        const keys = {};
        let mouseX = 0, mouseY = 0;
        let pitch = 0, yaw = 0;
        let mouseDown = false;

        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (gameActive && e.key === 'r' && !reloading && currentAmmo < 30 && totalAmmo > 0) reload();
        });

        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousemove', e => {
            if (!gameActive || !document.pointerLockElement) return;
            mouseX = e.movementX * player.turnSpeed;
            mouseY = e.movementY * player.turnSpeed;
            yaw -= mouseX;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch - mouseY));
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            document.querySelector('.minimap-direction').style.transform = 
                `translate(-50%, -50%) rotate(${yaw * 180 / Math.PI + 90}deg)`;
        });

        document.addEventListener('mousedown', e => {
            if (!gameActive || e.button !== 0) return;
            mouseDown = true;
            if (currentAmmo > 0 && !reloading) shoot();
        });

        document.addEventListener('mouseup', e => {
            if (e.button === 0) mouseDown = false;
        });

        document.addEventListener('click', e => {
            if (gameActive && e.target.tagName !== 'BUTTON') {
                renderer.domElement.requestPointerLock();
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function reload() {
            if (reloading || currentAmmo === 30 || totalAmmo === 0) return;
            reloading = true;
            document.getElementById('ammo-counter').textContent = "Reloading...";
            setTimeout(() => {
                const ammoNeeded = 30 - currentAmmo;
                const ammoToAdd = Math.min(ammoNeeded, totalAmmo);
                currentAmmo += ammoToAdd;
                totalAmmo -= ammoToAdd;
                document.getElementById('ammo-counter').textContent = `${currentAmmo} / ${totalAmmo}`;
                reloading = false;
            }, 1500);
        }

        let lastShot = 0;
        function shoot() {
            const now = performance.now();
            if (reloading || currentAmmo <= 0 || now - lastShot < 100) return;
            lastShot = now;
            currentAmmo--;
            document.getElementById('ammo-counter').textContent = `${currentAmmo} / ${totalAmmo}`;
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const bullet = new Bullet(camera.position.clone(), direction);
            bullets.push(bullet);
        }

        function updatePlayerMovement(delta) {
            if (!gameActive) return;

            const moveSpeed = keys['shift'] ? player.speed * player.sprintMultiplier : player.speed;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();

            const velocity = new THREE.Vector3();
            if (keys['w']) velocity.add(forward.multiplyScalar(moveSpeed));
            if (keys['s']) velocity.sub(forward.multiplyScalar(moveSpeed));
            if (keys['a']) velocity.sub(right.multiplyScalar(moveSpeed));
            if (keys['d']) velocity.add(right.multiplyScalar(moveSpeed));

            player.velocity.x += (velocity.x - player.velocity.x) * 0.1;
            player.velocity.z += (velocity.z - player.velocity.z) * 0.1;
            player.velocity.y -= player.gravity;

            if (keys[' '] && player.canJump) {
                player.velocity.y = player.jumpForce;
                player.canJump = false;
            }

            const newPos = camera.position.clone().add(player.velocity.clone().multiplyScalar(delta));
            const groundHeight = getHeightAtPosition(newPos.x, newPos.z);
            
            if (newPos.y < groundHeight + player.height) {
                newPos.y = groundHeight + player.height;
                player.velocity.y = 0;
                player.canJump = true;
            }

            camera.position.copy(newPos);
        }

        function takeDamage(amount) {
            if (!gameActive) return;
            health -= amount;
            if (health <= 0) {
                health = 0;
                gameOver(false);
            }
            document.getElementById('health-fill').style.width = health + '%';
        }

        function spawnEnemies() {
            if (!gameActive || !heliTexture) return;
            enemies.forEach(enemy => enemy.remove());
            enemies.length = 0;
            for (let i = 0; i < maxEnemies; i++) {
                enemies.push(new AirborneEnemy());
            }
            console.log(`Spawned ${enemies.length} enemies`);
        }

        function checkWinCondition() {
            if (gameActive && kills >= maxEnemies && enemies.length === 0) {
                gameOver(true);
            }
        }

        function gameOver(playerWon) {
            gameActive = false;
            const title = document.getElementById('game-over-title');
            const subtitle = document.getElementById('game-over-subtitle');
            if (playerWon) {
                title.textContent = "Victory";
                subtitle.textContent = "You repelled the air assault!";
            } else {
                title.textContent = "Mission Failed";
                subtitle.textContent = "You were overwhelmed!";
            }
            document.getElementById('game-over').style.display = 'flex';
            bullets.forEach(bullet => bullet.remove());
            enemyBullets.forEach(bullet => bullet.remove());
            bullets.length = 0;
            enemyBullets.length = 0;
            stopBackgroundMusic();
            document.exitPointerLock();
        }

        function resetGame() {
            document.getElementById('game-over').style.display = 'none';
            gameActive = true;
            health = 100;
            currentAmmo = 30;
            totalAmmo = 300;
            kills = 0;
            reloading = false;
            mouseDown = false;
            pitch = 0;
            yaw = 0;
            player.velocity.set(0, 0, 0);
            player.canJump = false;

            enemies.forEach(enemy => enemy.remove());
            enemies.length = 0;
            bullets.forEach(bullet => bullet.remove());
            enemyBullets.forEach(bullet => bullet.remove());
            bullets.length = 0;
            enemyBullets.length = 0;

            document.getElementById('minimap-content').innerHTML = `
                <div class="minimap-player"></div>
                <div class="minimap-direction"></div>
            `;
            document.getElementById('health-fill').style.width = '100%';
            document.getElementById('ammo-counter').textContent = `${currentAmmo} / ${totalAmmo}`;
            document.getElementById('kill-counter').textContent = `Kills: 0`;

            camera.position.set(0, player.height, 0);
            camera.rotation.set(0, 0, 0);

            spawnEnemies();
            startBackgroundMusic();
        }

        document.getElementById('restart-button').addEventListener('click', resetGame);

        let frameCount = 0;
        let lastTime = performance.now();
        const fpsElement = document.getElementById('fps-counter');

        function updateFPS() {
            const currentTime = performance.now();
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                fpsElement.textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        let lastFrame = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = Math.min((now - lastFrame) / 1000, 0.1);
            lastFrame = now;

            updateFPS();
            if (gameActive) {
                updatePlayerMovement(delta);
                enemies.forEach(enemy => enemy.update(delta));
                bullets.forEach(bullet => bullet.update(delta));
                enemyBullets.forEach(bullet => bullet.update(delta));
                if (mouseDown && currentAmmo > 0 && !reloading) shoot();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
